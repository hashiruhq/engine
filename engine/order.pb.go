// Code generated by protoc-gen-go. DO NOT EDIT.
// source: order.proto

package engine

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type MarketSide int32

const (
	// BUY value means the user wants to buy from the market
	MarketSide_Buy MarketSide = 0
	// SELL value means the user wants to sell to the market
	MarketSide_Sell MarketSide = 1
)

var MarketSide_name = map[int32]string{
	0: "Buy",
	1: "Sell",
}

var MarketSide_value = map[string]int32{
	"Buy":  0,
	"Sell": 1,
}

func (x MarketSide) String() string {
	return proto.EnumName(MarketSide_name, int32(x))
}

func (MarketSide) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_cd01338c35d87077, []int{0}
}

type OrderType int32

const (
	// LimitOrder allows the trader to start an order where the transaction will be completed
	// if the market price is at or better than the set price
	OrderType_Limit OrderType = 0
	// MarketOrder completes the trade at the current market price
	OrderType_Market OrderType = 1
)

var OrderType_name = map[int32]string{
	0: "Limit",
	1: "Market",
}

var OrderType_value = map[string]int32{
	"Limit":  0,
	"Market": 1,
}

func (x OrderType) String() string {
	return proto.EnumName(OrderType_name, int32(x))
}

func (OrderType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_cd01338c35d87077, []int{1}
}

type OrderStatus int32

const (
	// StatusPending is used when the order has not yet been processed by the matching engine
	OrderStatus_Pending OrderStatus = 0
	// StatusUntouched means that the order was processed by the engine but it did not yet match with any order
	OrderStatus_Untouched OrderStatus = 1
	// StatusPartiallyFilled is used when the order was not completely filled
	OrderStatus_PartiallyFilled OrderStatus = 2
	// StatusCancelled is used when the order has been cancelled
	OrderStatus_Cancelled OrderStatus = 3
	// StatusFilled is used when the order was filled and th
	OrderStatus_Filled OrderStatus = 4
)

var OrderStatus_name = map[int32]string{
	0: "Pending",
	1: "Untouched",
	2: "PartiallyFilled",
	3: "Cancelled",
	4: "Filled",
}

var OrderStatus_value = map[string]int32{
	"Pending":         0,
	"Untouched":       1,
	"PartiallyFilled": 2,
	"Cancelled":       3,
	"Filled":          4,
}

func (x OrderStatus) String() string {
	return proto.EnumName(OrderStatus_name, int32(x))
}

func (OrderStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_cd01338c35d87077, []int{2}
}

type StopLoss int32

const (
	// By default an order has its stop loss flag set to disabled
	StopLoss_None StopLoss = 0
	// Stop loss triggers when the last trade price changes to a value at or below the `StopPrice`
	StopLoss_Loss StopLoss = 1
	// Stop entry triggers when the last trade price changes to a value at or above the `StopPrice`
	StopLoss_Entry StopLoss = 2
)

var StopLoss_name = map[int32]string{
	0: "None",
	1: "Loss",
	2: "Entry",
}

var StopLoss_value = map[string]int32{
	"None":  0,
	"Loss":  1,
	"Entry": 2,
}

func (x StopLoss) String() string {
	return proto.EnumName(StopLoss_name, int32(x))
}

func (StopLoss) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_cd01338c35d87077, []int{3}
}

type CommandType int32

const (
	// A new order should be added in the order book
	CommandType_NewOrder CommandType = 0
	// An existing order should be cancelled if it's not already filled
	CommandType_CancelOrder CommandType = 1
	// The whole market should be archived and stored in a safe location
	// This command may not be needed since the engine should already create regular backups of the current orderbook
	CommandType_BackupMarket CommandType = 2
)

var CommandType_name = map[int32]string{
	0: "NewOrder",
	1: "CancelOrder",
	2: "BackupMarket",
}

var CommandType_value = map[string]int32{
	"NewOrder":     0,
	"CancelOrder":  1,
	"BackupMarket": 2,
}

func (x CommandType) String() string {
	return proto.EnumName(CommandType_name, int32(x))
}

func (CommandType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_cd01338c35d87077, []int{4}
}

// Order allows the trader to start an order where the transaction will be completed
// if the market price is at or better than the set price
type Order struct {
	// The event type signals what operation can be executed on the market engine
	// 0 = New Order
	// 1 = Cancel Order
	// 2 = Backup Market
	EventType CommandType `protobuf:"varint,1,opt,name=EventType,proto3,enum=engine.CommandType" json:"EventType,omitempty"`
	// The type of the order: 0=limit 1=market
	Type OrderType `protobuf:"varint,2,opt,name=Type,proto3,enum=engine.OrderType" json:"Type,omitempty"`
	// Category int8 // deprecated by the Type field
	// The side of the market: 0=buy 1=sell
	Side MarketSide `protobuf:"varint,3,opt,name=Side,proto3,enum=engine.MarketSide" json:"Side,omitempty"`
	// Optional:
	// Amount of coins to buy/sell with the order
	// - The amount must be greater than the base_min_amount for the product and no larger than the base_max_amount.
	Amount uint64 `protobuf:"varint,4,opt,name=Amount,proto3" json:"Amount,omitempty"`
	// Optional:
	// The price to pay for one unit in the market
	// - The price must be specified in quote_increment product units.
	// - The quote increment is the smallest unit of price. For the BTC-USD product,
	//   the quote increment is 0.01 or 1 penny. Prices less than 1 penny will not be accepted,
	//   and no fractional penny prices will be accepted. Not required for market orders.
	Price uint64 `protobuf:"varint,5,opt,name=Price,proto3" json:"Price,omitempty"`
	// Stop flag. Requires `StopPrice`` to be defined.
	// Stop orders become active and wait to trigger based on the movement of the last trade price.
	// There are 2 types of stop orders: 0=none 1=loss 2=entry
	// - Stop loss triggers when the last trade price changes to a value at or below the `StopPrice`.
	// - Stop entry triggers when the last trade price changes to a value at or above the `StopPrice`.
	// - Note that when triggered, stop orders execute as either market or limit orders, depending on the type.
	Stop StopLoss `protobuf:"varint,6,opt,name=Stop,proto3,enum=engine.StopLoss" json:"Stop,omitempty"`
	// Sets trigger price for stop order. Only if stop is defined.
	StopPrice uint64 `protobuf:"varint,7,opt,name=StopPrice,proto3" json:"StopPrice,omitempty"`
	// Maximum total funds to use for the order
	// - The funds field is optionally used for market orders. When specified it indicates how much of the product
	//   quote currency to buy or sell. For example, a market buy for BTC-USD with funds specified as 150.00 will
	//   spend 150 USD to buy BTC (including any fees). If the funds field is not specified for a market buy order,
	//   size must be specified and the enting will use available funds in your account to buy bitcoin.
	// - A market sell order can also specify the funds. If funds is specified, it will limit the sell to the amount
	//   of funds specified. You can use funds with sell orders to limit the amount of quote currency funds received.
	Funds uint64 `protobuf:"varint,8,opt,name=Funds,proto3" json:"Funds,omitempty"`
	//******************************************
	// Common fields
	//******************************************
	// The id of the order
	ID string `protobuf:"bytes,9,opt,name=ID,proto3" json:"ID,omitempty"`
	// The market for which this order is for. Ex: eth-btc
	Market string `protobuf:"bytes,10,opt,name=Market,proto3" json:"Market,omitempty"`
	// The status is dictated by the stage in the execution of the order by the matching engine
	// 0 = Pending
	// 1 = Untouched
	// 2 = Partially Filled
	// 3 = Cancelled
	// 4 = Filled
	Status               OrderStatus `protobuf:"varint,11,opt,name=Status,proto3,enum=engine.OrderStatus" json:"Status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Order) Reset()         { *m = Order{} }
func (m *Order) String() string { return proto.CompactTextString(m) }
func (*Order) ProtoMessage()    {}
func (*Order) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd01338c35d87077, []int{0}
}

func (m *Order) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Order.Unmarshal(m, b)
}
func (m *Order) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Order.Marshal(b, m, deterministic)
}
func (m *Order) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Order.Merge(m, src)
}
func (m *Order) XXX_Size() int {
	return xxx_messageInfo_Order.Size(m)
}
func (m *Order) XXX_DiscardUnknown() {
	xxx_messageInfo_Order.DiscardUnknown(m)
}

var xxx_messageInfo_Order proto.InternalMessageInfo

func (m *Order) GetEventType() CommandType {
	if m != nil {
		return m.EventType
	}
	return CommandType_NewOrder
}

func (m *Order) GetType() OrderType {
	if m != nil {
		return m.Type
	}
	return OrderType_Limit
}

func (m *Order) GetSide() MarketSide {
	if m != nil {
		return m.Side
	}
	return MarketSide_Buy
}

func (m *Order) GetAmount() uint64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *Order) GetPrice() uint64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *Order) GetStop() StopLoss {
	if m != nil {
		return m.Stop
	}
	return StopLoss_None
}

func (m *Order) GetStopPrice() uint64 {
	if m != nil {
		return m.StopPrice
	}
	return 0
}

func (m *Order) GetFunds() uint64 {
	if m != nil {
		return m.Funds
	}
	return 0
}

func (m *Order) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Order) GetMarket() string {
	if m != nil {
		return m.Market
	}
	return ""
}

func (m *Order) GetStatus() OrderStatus {
	if m != nil {
		return m.Status
	}
	return OrderStatus_Pending
}

func init() {
	proto.RegisterEnum("engine.MarketSide", MarketSide_name, MarketSide_value)
	proto.RegisterEnum("engine.OrderType", OrderType_name, OrderType_value)
	proto.RegisterEnum("engine.OrderStatus", OrderStatus_name, OrderStatus_value)
	proto.RegisterEnum("engine.StopLoss", StopLoss_name, StopLoss_value)
	proto.RegisterEnum("engine.CommandType", CommandType_name, CommandType_value)
	proto.RegisterType((*Order)(nil), "engine.Order")
}

func init() { proto.RegisterFile("order.proto", fileDescriptor_cd01338c35d87077) }

var fileDescriptor_cd01338c35d87077 = []byte{
	// 414 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x54, 0x92, 0x5f, 0x8b, 0xd3, 0x40,
	0x14, 0xc5, 0x3b, 0x69, 0x9a, 0x36, 0x37, 0xeb, 0xee, 0x78, 0x57, 0x64, 0x1e, 0x04, 0xcb, 0xa2,
	0x52, 0x23, 0x14, 0xd4, 0x77, 0xc1, 0xfd, 0x07, 0x0b, 0xeb, 0x5a, 0x52, 0x7d, 0xf0, 0x31, 0x36,
	0xc3, 0x3a, 0x6c, 0x32, 0x13, 0x92, 0x89, 0x92, 0x2f, 0xec, 0xe7, 0x90, 0xb9, 0x93, 0xd8, 0xee,
	0x53, 0xb8, 0xe7, 0xfc, 0x72, 0xe6, 0xcc, 0x65, 0x20, 0x31, 0x4d, 0x21, 0x9b, 0x75, 0xdd, 0x18,
	0x6b, 0x30, 0x92, 0xfa, 0x5e, 0x69, 0x79, 0xf6, 0x37, 0x80, 0xd9, 0x57, 0xa7, 0xe3, 0x7b, 0x88,
	0xaf, 0x7e, 0x4b, 0x6d, 0xbf, 0xf5, 0xb5, 0x14, 0x6c, 0xc9, 0x56, 0xc7, 0x1f, 0x4e, 0xd7, 0x9e,
	0x5a, 0x5f, 0x98, 0xaa, 0xca, 0x75, 0xe1, 0xac, 0x6c, 0x4f, 0xe1, 0x6b, 0x08, 0x89, 0x0e, 0x88,
	0x7e, 0x3a, 0xd2, 0x94, 0x47, 0x2c, 0xd9, 0xf8, 0x06, 0xc2, 0xad, 0x2a, 0xa4, 0x98, 0x12, 0x86,
	0x23, 0xf6, 0x25, 0x6f, 0x1e, 0xa4, 0x75, 0x4e, 0x46, 0x3e, 0x3e, 0x87, 0xe8, 0x73, 0x65, 0x3a,
	0x6d, 0x45, 0xb8, 0x64, 0xab, 0x30, 0x1b, 0x26, 0x7c, 0x06, 0xb3, 0x4d, 0xa3, 0x76, 0x52, 0xcc,
	0x48, 0xf6, 0x03, 0xbe, 0x82, 0x70, 0x6b, 0x4d, 0x2d, 0x22, 0x4a, 0xe5, 0x63, 0xaa, 0xd3, 0x6e,
	0x4d, 0xdb, 0x66, 0xe4, 0xe2, 0x0b, 0x88, 0xdd, 0xd7, 0xff, 0x3f, 0xa7, 0xff, 0xf7, 0x82, 0x4b,
	0xbe, 0xee, 0x74, 0xd1, 0x8a, 0x85, 0x4f, 0xa6, 0x01, 0x8f, 0x21, 0xb8, 0xb9, 0x14, 0xf1, 0x92,
	0xad, 0xe2, 0x2c, 0xb8, 0xb9, 0x74, 0xbd, 0x7c, 0x57, 0x01, 0xa4, 0x0d, 0x13, 0xbe, 0x83, 0x68,
	0x6b, 0x73, 0xdb, 0xb5, 0x22, 0x79, 0xbc, 0x2e, 0x5a, 0x80, 0xb7, 0xb2, 0x01, 0x49, 0x5f, 0x02,
	0xec, 0x2f, 0x8c, 0x73, 0x98, 0x9e, 0x77, 0x3d, 0x9f, 0xe0, 0x02, 0xc2, 0xad, 0x2c, 0x4b, 0xce,
	0xd2, 0x33, 0x88, 0xff, 0x2f, 0x0e, 0x63, 0x98, 0xdd, 0xaa, 0x4a, 0x59, 0x3e, 0x41, 0x18, 0x4f,
	0xe7, 0x2c, 0xfd, 0x01, 0xc9, 0x41, 0x36, 0x26, 0x30, 0xdf, 0x48, 0x5d, 0x28, 0x7d, 0xcf, 0x27,
	0xf8, 0x04, 0xe2, 0xef, 0xda, 0x9a, 0x6e, 0xf7, 0x4b, 0x16, 0x9c, 0xe1, 0x29, 0x9c, 0x6c, 0xf2,
	0xc6, 0xaa, 0xbc, 0x2c, 0xfb, 0x6b, 0x55, 0x96, 0xb2, 0xe0, 0x81, 0x63, 0x2e, 0x72, 0xbd, 0x93,
	0x34, 0x4e, 0x5d, 0xf4, 0x60, 0x85, 0xe9, 0x5b, 0x58, 0x8c, 0xab, 0x73, 0xa5, 0xee, 0x8c, 0x96,
	0xbe, 0x9e, 0x53, 0x38, 0x73, 0x8d, 0xae, 0xb4, 0x6d, 0x7a, 0x1e, 0xa4, 0x9f, 0x20, 0x39, 0x78,
	0x10, 0x78, 0x04, 0x8b, 0x3b, 0xf9, 0x87, 0x7a, 0xf1, 0x09, 0x9e, 0x40, 0xe2, 0x8f, 0xf0, 0x02,
	0x43, 0x0e, 0x47, 0xe7, 0xf9, 0xee, 0xa1, 0xab, 0x87, 0x5b, 0x04, 0x3f, 0x23, 0x7a, 0x82, 0x1f,
	0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0x7b, 0xf5, 0x5a, 0x59, 0x91, 0x02, 0x00, 0x00,
}
